Writeup for Crackme-4 by D4RLFL0W: crackmes.one
Difficulty: Easy
Language: C/C++
Platform: Unix/Linux
07/04/2020
Jake Mai

Unzip the archive, we have a binary, make it executable with chmod +x
A simple password check binary.
Let's try with the basic: strings, ltrace. Okay so the password check is hidden and not in plain text obviously.

Fireup Ghidra (not sure if this is cheating, but using Ghidra or any other decompiler sure makes it easier)
Locate the entry point, main():
-------------------------
	Vault local_28 [32];
  
  	prompt(local_28);
  	return 0;
-------------------------

We have a buffer and a prompt function.
Let's go to prompt():
-------------------------
	  operator<<<std--char_traits<char>>((basic_ostream *)__TMC_END__,"\nPlease enter the password: ");
	  getline(cin,(long)(this + 8));
	  checkPassword(this);
	  return;
-------------------------
Does this and that, prints the prompt, asks for user input, the it CALLS checkPasswor with the argument being the input

Let's go to checkPassword:
-------------------------
	  char cVar1;
	  
	  buildPassword((PasswordGen *)this);
	  cVar1 = checkPassword((PasswordGen *)this,(char *)(this + 8));
	  if (cVar1 != '\0') {
	    operator<<<std--char_traits<char>>
	              ((basic_ostream *)__TMC_END__,"\nThat\'s CORRECT, Well Done.\n");
	  }
	  return;
--------------------------
Okay we can see the check condition, fairly simple. The checkPassword function on the fourth line is actually another function, I thought at first this was called recursively.

Looking at buildPassword, I assumed okay the generated password is 10 character long, with each character generated by 10 different functions (from c0 to c9)
--------------------------
	  undefined var1;
	  void *pvVar1;
	  long lVar2;
	  
	  pvVar1 = operator.new[](10);
	  *(void **)this = pvVar1;
	  var1 = c0();
	  **(undefined **)this = var1;
	  var1 = c1();
	  *(undefined *)(*(long *)this + 1) = var1;
	  var1 = c2();
	  *(undefined *)(*(long *)this + 2) = var1;
	  var1 = c3();
	  *(undefined *)(*(long *)this + 3) = var1;
	  var1 = c4();
	  *(undefined *)(*(long *)this + 4) = var1;
	  var1 = c5();
	  *(undefined *)(*(long *)this + 5) = var1;
	  var1 = c6();
	  *(undefined *)(*(long *)this + 6) = var1;
	  lVar2 = c7();
	  *(undefined *)(*(long *)this + 7) = (char)lVar2;
	  var1 = c8();
	  *(undefined *)(*(long *)this + 8) = var1;
	  var1 = c9();
	  *(undefined *)(*(long *)this + 9) = var1;
	  return;
----------------------------
And checkPassword function on the fourth line checks the input password given by the user character by character with this generated one.
Analyse all 10 functions: c0-c9, they all return a number:
85, 54, 45, 58, 89, 76, 46, 34, 43, 10 respectively.
10 character password, let's convert them to ascii, just by using a few lines Python program
-----------------------------
a = [85, 54, 45, 58, 89, 76, 46, 34, 43, 10]
def togetha():
    passwd = ""
    for i in a:
        passwd+=str(chr(i))
    print(passwd)
if __name__ == "__main__":
    togetha()
------------------------------
Output:U6-:YL."+
At first, I thought I did something wrong when there were only 9 characters, but then I realised 10 in ascii is a new line character.

Put this in the program, we got the prompt:
"That's CORRECT, Well Done."
